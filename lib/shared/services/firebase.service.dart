// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'dart:developer';

import 'package:chat/models/firebase.model.dart';
import 'package:chat/shared/services.dart';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:firebase_core/firebase_core.dart'
    show Firebase, FirebaseOptions;
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:firebase_remote_config/firebase_remote_config.dart';
import 'package:flutter/foundation.dart'
    show
        FlutterError,
        PlatformDispatcher,
        TargetPlatform,
        defaultTargetPlatform,
        kIsWeb;
import 'package:get/get.dart';

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for ios - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyALQu34axFBaJoGVNeW1jKF6jztAIYkOJc',
    appId: '1:470323018445:web:f675d2f2bb5e26a1f3c784',
    messagingSenderId: '470323018445',
    projectId: 'mahasal-project',
    authDomain: 'mahasal-project.firebaseapp.com',
    storageBucket: 'mahasal-project.firebasestorage.app',
    measurementId: 'G-8P5YW3TLB7',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAnpYUkhOEhAm_RdeJ2DsYiuz1U8bWF0k0',
    appId: '1:470323018445:android:7f5bc8ac36645028f3c784',
    messagingSenderId: '470323018445',
    projectId: 'mahasal-project',
    storageBucket: 'mahasal-project.firebasestorage.app',
  );
}

class FirebaseService extends GetxService {
  Future<void> init() async {
    if (kIsWeb) {
      return;
    }

    log('[firebase.service.dart] firebase');
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    log('[firebase.service.dart] firebase_crashlytics');
    // Pass all uncaught "fatal" errors from the framework to Crashlytics
    FlutterError.onError = (errorDetails) {
      FirebaseCrashlytics.instance.recordFlutterFatalError(errorDetails);
    };
    // Pass all uncaught asynchronous errors that aren't handled by the Flutter framework to Crashlytics
    PlatformDispatcher.instance.onError = (error, stack) {
      FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
      return true;
    };
    log('[firebase.service.dart] firebase_crashlytics');
    FirebaseAnalytics.instance;

    log('[firebase.service.dart] firebase_remote_config');
    FirebaseRemoteConfig.instance;
    // await FirebaseRemoteConfig.instance.fetchAndActivate();

    log('[firebase.service.dart] firebase_messaging');
    FirebaseMessaging.onMessage.listen((RemoteMessage message) {
      print('Got a message whilst in the foreground!');
      print('Message data: ${message.data}');

      if (message.notification != null) {
        print('Message also contained a notification: ${message.notification}');

        // show notification
        var id = DateTime.now().microsecondsSinceEpoch;

        Services.notification.make(
          id: id,
          title: message.notification!.title ?? '',
          body: message.notification!.body,
        );
      }
    });
  }

  Future<String?> get token async {
    try {
      return await FirebaseMessaging.instance.getToken();
    } catch (e) {
      return null;
    }
  }

  // request for notifications access
  Future<bool> permission() async {
    NotificationSettings settings =
        await FirebaseMessaging.instance.requestPermission();
    return settings.authorizationStatus == AuthorizationStatus.authorized;
  }

  // check has notification access
  Future<bool> get access async {
    final settings = await FirebaseMessaging.instance.getNotificationSettings();
    return settings.authorizationStatus == AuthorizationStatus.authorized;
  }

  Future<void> crash(String error) async {
    FirebaseCrashlytics.instance.recordError(error, null, fatal: true);
  }

  Future<void> event({
    required FIREBASE_EVENT_TYPE type,
    dynamic data,
  }) async {
    // switch case for each type
    switch (type) {
      case FIREBASE_EVENT_TYPE.APP_OPEN:
        await FirebaseAnalytics.instance.logAppOpen();
        break;
      case FIREBASE_EVENT_TYPE.PURCHASE:
        await FirebaseAnalytics.instance.logPurchase(
          currency: "TOMAN",
          transactionId: data['id'],
          items: [
            AnalyticsEventItem(itemId: data['plan'], price: data['price'])
          ],
        );
        break;
      case FIREBASE_EVENT_TYPE.CONSUME:
        await FirebaseAnalytics.instance.logEvent(
          name: "consume",
          parameters: {"id": data['id']},
        );
        break;
      case FIREBASE_EVENT_TYPE.LOGIN:
        await FirebaseAnalytics.instance.logLogin();
        break;
      case FIREBASE_EVENT_TYPE.SHARE:
        await FirebaseAnalytics.instance.logEvent(
          name: "share",
        );
      case FIREBASE_EVENT_TYPE.COMMENT:
        await FirebaseAnalytics.instance.logEvent(
          name: "comment",
        );
      case FIREBASE_EVENT_TYPE.LOGOUT:
        await FirebaseAnalytics.instance.logEvent(
          name: "logout",
        );
    }
    log('[firebase.service.dart] log event $type');
  }

  Future<String?> getStringFromRemote({required String key}) async {
    var value = FirebaseRemoteConfig.instance.getString(key);

    log('[firebase.service.dart] remote config key=$key value=$value');

    return value;
  }
}
